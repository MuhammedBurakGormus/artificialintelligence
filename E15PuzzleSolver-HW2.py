#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Created on Tue Oct 27 16:25:35 2020

@author: muhammedburakgormus
"""

"""SECTION2 - GROUP BIFKE
GROUP MEMBERS:  21602797 - Muhammed Burak Görmüş
	  	21602930 - Abdullah Fırat Uyar
		21501551 - İpeksu Tutsak
		21000292 - Koral Yıldıran
		21802629 - Salih Efe Boyacı """

"""
We implemented A* search algorithm without the dynamic programming.
When the code is run, the program will generate 12 states from the goal state. These 12 different states are displayed.
The solutions of 2 of these initial states are displayed graphically. Every intermediate states between the initial 
and the final state are shown along with the steps taken. For the remaining 10 instances, a graph which shows the maximum number
of paths in the queue at any instance for the corresponding state is created.

In Part A, the program creates 12 distinct initial states by randomly moving the empty file 10 times in a row. These distinct
states are stored in a list and displayed to the user.
In Part B, the program takes the first and second initial states from the list and displays the solutions of these initial states
separately.
In Part C, the program plots the graph of maximum number of paths in the queue at any instance during the solving process of 
remaining 10 initial states.
"""
import random
import matplotlib.pyplot as plt
import numpy as np

#######################################################################################################
goal_state = [[1,2,3,4],
              [2,3,4,5],
              [3,4,5,5],
              [4,5,5," "]]   
#######################################################################################################

#######################################################################################################
class Puzzle():

    def __init__(self,puzzle_array):
        #Initialize the attributes of a class.
        self.state = puzzle_array
        self.parent = None
        
    def __str__(self):
        #Provide a string representation of the object
        a = ""
        for r in range(len(self.state)):
            for c in range(len(self.state[0])):
                a =  a + str(self.state[r][c]) + " "
            a = a + "\n"
        return(a)
    
    def find_position(self,value):
        """The position of an integer is located by tracing every tile of the given state
        --- The position of the integer is returened for every encounter"""
        for i in range(len(self.state)):
            for j in range(len(self.state)):
                if self.state[i][j] == value:
                    return(i,j)
                
    def get_item(self,my_tuple):
        """This method takes the location of an entry from a tuple and returns the value
        --- of the located entry"""
        row_no = my_tuple[0]
        col_no = my_tuple[1]
        item = self.state[row_no][col_no]
        return item
        
    def puzzle_generator(self):
        """ An E15-puzzle is generated by the movement of empty tile 10 times.
        --- Location of the empty tile is found by "find_position" method. Depending on the 
        --- generated random integer, empty tile moves to one of the four directions. This is repeated
        --- until the counter reaches 10"""
        counter = 0
        while counter < 10:
            row = self.find_position(" ")[0]
            col = self.find_position(" ")[1]
            random_number = random.randint(1, 4)
            if random_number == 1 and row != 0: #UP
                counter = counter +1
                self.state[row-1][col], self.state[row][col] = self.state[row][col], self.state[row-1][col]
            elif random_number == 2 and row != 3: #DOWN
                counter = counter +1
                self.state[row+1][col], self.state[row][col] = self.state[row][col], self.state[row+1][col]  
            elif random_number == 3 and col != 0: #ROGHT
                counter = counter +1
                self.state[row][col-1], self.state[row][col] = self.state[row][col], self.state[row][col-1]
            elif random_number == 4 and col != 3: #LEFT
                counter = counter +1
                self.state[row][col+1], self.state[row][col] = self.state[row][col], self.state[row][col+1]
        return self
    
    def find_h1(self):
        """ Tiles of the given state is compared with the tiles of the goal state.
        --- Every time an integer is detected being in the wrong tile, h1 is increased by 1, thus
        --- this method returns the number of dislocated integers"""
        h1 = 0
        for i in range(len(self.state)):
            for j in range(len(self.state)):
                if self.state[i][j] != goal_state[i][j]:
                    h1 = h1 + 1
        return h1
    
    def find_h2(self):
        """The minimum Manhattan distance of an integer from its current tile to the required tile is calcuated.
        --- If the integer is located in the right tile, h2 is not increased. If its tile is wrong, h2 is increased
        --- by the calculated Manhattan distance. This process is repeated for every tile of the given state, and this method
        --- returns the sum of Manhattan distances of all tiles"""
        h2 = 0 
        for i in range(len(self.state)):
            for j in range(len(self.state)):
                if self.state[i][j] != goal_state[i][j]:
                    if self.state[i][j] == 1:
                        h2 = h2 + (abs(i-0)+abs(j-0))
                    if self.state[i][j] == 2:
                        h2 = h2 + min((abs(i-0)+abs(j-1)),(abs(i-1)+abs(j-0)))
                    if self.state[i][j] == 3:
                        h2 = h2 + min((abs(i-0)+abs(j-2)),(abs(i-1)+abs(j-1)),(abs(i-2)+abs(j-0)))
                    if self.state[i][j] == 4:
                        h2 = h2 + min((abs(i-0)+abs(j-3)),(abs(i-1)+abs(j-2)),(abs(i-2)+abs(j-1)),(abs(i-3)+abs(j-0)))
                    if self.state[i][j] == 5:
                        h2 = h2 + min((abs(i-1)+abs(j-3)),(abs(i-2)+abs(j-2)),(abs(i-2)+abs(j-3)),(abs(i-3)+abs(j-1)),(abs(i-3)+abs(j-2)))
                    if self.state[i][j] == " ":
                        h2 = h2 + (abs(i-3)+abs(j-3))
        return h2
    
    def get_info(self):
        """The sum of h1 and h2 values determines the distance from a given state to 
        --- the goal state. Therefore, the sum of h1 and h2 is returned in order to be
        --- used while sorting the queue after each step"""
        return self.find_h1()+self.find_h2()
      
    def get_array(self):
        my_list = []
        for i in range(len(self.state[0])):
            row_list = []
            for j in range(len(self.state[1])):
                row_list.append(self.state[i][j])
            my_list.append(row_list)
        return my_list
    
    def is_succeed(self):
        # Given state is compared with the goal state
        # Returns True if the goal state is reached, returns False otherwise
        if self.state == goal_state:
            return True
        else:
            return False
    
    def __eq__(self,other):
        # Equality of two states is identified by checking every elements
        a = [(i,j) for i in range(4) for j in range(4)]
        for elements in a:
            if self.get_item(elements) != other.get_item(elements):
                return False
        return True
    
    def __hash__(self):
        #hashing the objects attributes to create nodes and later check it
        a = [(i,j) for i in range(4) for j in range(4)]
        return hash((self.get_item(elements) for elements in a))
    
    def __lt__(self,other):
        #making comparisons between two objects based on their sum of h1 and h2
        #it implements the less than operator
        a = self.get_info()
        b = other.get_info()
        if a < b:
            return True
        else:
            return False
#######################################################################################################



#######################################################################################################
def create_12_initial_distinct_states():
    """This funtion creates 12 initial states from the goal state. The function starts with creating
    ---and empty list and a counter, then the function defines the goal state. The empty tile of the goal
    ---goal state is moved by calling "puzzle_generator()" and a new initial state is defined. The new initial
    ---state is appended to the list_states if it is not already defined and not equal to goal state. list_states
    ---takes new initial states until it has 12 distinct initial states"""
    list_states = []
    counter = 0
    while counter < 12: 
        aimed_state = [[1,2,3,4],
                    [2,3,4,5],
                    [3,4,5,5],
                    [4,5,5," "]]   
        my_obj = Puzzle(aimed_state)
        initial_state = my_obj.puzzle_generator()    
        final_state = [[1,2,3,4],
                    [2,3,4,5],
                    [3,4,5,5],
                    [4,5,5," "]]   
        goal_obj = Puzzle(final_state)
        if (initial_state not in list_states) and (initial_state != goal_obj ):
            counter = counter + 1
            list_states.append(initial_state)
    return list_states
      
def print_states(distinct_states):
    # The created intial states are displayed one by one
    for i in range(len(distinct_states)):
        print("Initial State"+str(i+1)+":S"+str(i+1))
        print(distinct_states[i])
#######################################################################################################



#######################################################################################################        
def generate_successor(an_object):
    """This funtion determines the successors of a root state. The successors are determined by moving the empty tile
    ---in any possible direction. The function starts with locating the empty tile. Depending on the location of the empty tile,
    ---different number of successors may be obtained. When the empty tile is located at the corners of the 4 x 4 array, it can only
    ---move in two directions,i.e. the state has two successors. Similarly, if the empty tile is located at one of the edges, the state
    ---can have three successors. The successor list is appended by all possible successors of the given root state. The root state is
    ---defined as the parent of the successor in order to be used while obtaining the solution path"""
    root = an_object
    successor = []
    loc_blank = root.find_position(" ")
    row = loc_blank[0]
    col = loc_blank[1]
    if row != 0 :
        child_array = root.get_array()
        child_array[row-1][col] ,child_array[row][col] = child_array[row][col], child_array[row-1][col]
        child = Puzzle(child_array)
        child.parent = an_object
        successor.append(child)
    if row != 3:
        child_array = root.get_array()
        child_array[row+1][col] ,child_array[row][col] = child_array[row][col], child_array[row+1][col]
        child = Puzzle(child_array)
        child.parent = an_object
        successor.append(child)
    if col != 0:
        child_array = root.get_array()
        child_array[row][col-1] ,child_array[row][col] = child_array[row][col], child_array[row][col-1]
        child = Puzzle(child_array)
        child.parent = an_object
        successor.append(child)
    if col != 3:
        child_array = root.get_array()
        child_array[row][col+1] ,child_array[row][col] = child_array[row][col], child_array[row][col+1]
        child = Puzzle(child_array)
        child.parent = an_object
        successor.append(child)
    return successor
      
def star_algorithm(root_state):
    # The function implements A* search by sorting the queue
    queue = [] #An empty queue is created 
    explored = set() #A set is defined to make sure that the explored states are not repeated
    queue.append(root_state) #The root state is added to the queue
    counter = 0
    while len(queue) != 0: #This loop continues as long as the queue is not empty
         state = queue.pop(0) #First element of the queue is taken to be examined
         if state.is_succeed() == True:
             return (state,len(queue)+1) #The funtion returns the first element of the queue and stops searching if it is the goal state
                                         #The function also returns the length of the queue for plotting the maximum number of paths in Part C
         explored.add(state) #adding the state to the explored set to aviod looping 
         children = generate_successor(state) #Sucessors of the state is obtained
         for kids in children:
             if (kids not in queue) and (kids not in explored):
                 queue.append(kids) #The queue is appended with every child that is not already explored
         queue.sort(key=lambda x: x.get_info()) #The queue is sorted based on h1 and h2 values
         counter = counter + 1
    return None   
     
def find_parents(final_state):
    #The path taken from a given state is obtained by reaching its parent. 
    #This function will be used when defining the solution path of any initial state
    path = []
    path.append(final_state)
    parent = final_state.parent
    while parent:
        path.append(parent)
        parent = parent.parent
    return path       
        
def print_path(path):
    #This function displays the path taken by printing all states between the inital and the goal state
    #The path defined in "find_parents" are reversed to sort the states starting from initial state
    beginning_to_end = []
    for i in reversed(path):
        beginning_to_end.append(i)
    #The movement of integers is printed by comparing the locations of empty tiles in two successive states    
    for i in range(len(beginning_to_end)-1):
        first_loc = beginning_to_end[i].find_position(" ")
        first_row = first_loc[0]
        first_col = first_loc[1]
        second_loc = beginning_to_end[i+1].find_position(" ")
        second_row = second_loc[0]
        second_col = second_loc[1]
        print(beginning_to_end[i])
        if first_row < second_row:
            print(str(beginning_to_end[i].get_item((first_row+1,first_col)))+" MOVES UP")  
            print() #Empty tile moves down, adjacent integer moves up
        elif first_row > second_row:
            print(str(beginning_to_end[i].get_item((first_row-1,first_col)))+" MOVES DOWN")
            print() #Empty tile moves up, adjacent integer moves down
        elif first_col > second_col:
            print(str(beginning_to_end[i].get_item((first_row,first_col-1)))+" MOVES RIGHT")
            print() #Empty tile moves left, adjacent integer moves right
        elif first_col < second_col:
            print(str(beginning_to_end[i].get_item((first_row,first_col+1)))+" MOVES LEFT")
            print() #Empty tile moves right, adjacent integer moves left
    print(beginning_to_end[len(beginning_to_end)-1])
#######################################################################################################
        
        
######################################################################################################
"""PART A: PRINTING OUT THE 12 DISTINCT INITIAL STATES
    This is the part printing out 12 distinct states. Thsese states are generated
    by the create_12_initial_distinct_states() function. Printing out these states are done
    by the function print_states."""
   
print("12 INITIAL DISTINCT STATES WHICH ARE GENERATED BY PUZZLE GENERATOR ARE AS FOLLOWS:\n")
distinct_initial_states = create_12_initial_distinct_states()
print_states(distinct_initial_states)      
#######################################################################################################



#######################################################################################################
"""
PART B: SHOWING SOLUTUON SEQUENCE FOR TWO INITIAL STATES
    In this part, the solution sequence of the FIRST two states generated at Part A will be shown.
"""
print("THE FIRST SOLUTION SEQUENCE(The root for this solution is the first state shown in part A): ")
first_sequence_root = distinct_initial_states[0]  
first_final_root = star_algorithm(first_sequence_root)[0]
first_path = find_parents(first_final_root)
print_path(first_path)


print("THE SECOND SOLUTION SEQUENCE(The root for this solution is the second state shown in part A): ")
second_sequence_root = distinct_initial_states[1]  
second_final_root = star_algorithm(second_sequence_root)[0]
second_path = find_parents(second_final_root)
print_path(second_path)
#######################################################################################################


#######################################################################################################
"""
PART C: SHOWING THE MAXIMUM LENGTH OF THE QUEUE FOR REMAINING 10 STATES
"""
distinct_initial_states.pop(0)
distinct_initial_states.pop(0)
max_queue_lenght = []
for i in range(len(distinct_initial_states)):
    queue_len =star_algorithm(distinct_initial_states[i])[1]
    max_queue_lenght.append(queue_len)
x_list = [3,4,5,6,7,8,9,10,11,12]
plt.scatter(x_list,max_queue_lenght)
plt.xticks(np.arange(min(x_list), max(x_list)+1, 1.0))
plt.xlabel("State")
plt.ylabel("Maximum Queue Length")
plt.title("Queue Length vs Instances(From the 3rd State to 12th State")
plt.show()
#####################################################################################################


